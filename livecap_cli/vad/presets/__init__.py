"""Optimized VAD parameter presets (JSON-backed).

Presets are stored as individual JSON files in this package directory
and loaded via ``importlib.resources.files()``.

File naming convention: ``{vad_type}_{language}_{engine}.json``

These presets were generated by Bayesian optimization (Optuna TPE sampler)
using benchmark corpora:
- Japanese (JA): JSUT basic5000 subset
- English (EN): LibriSpeech test-clean subset

See Issue #126 for detailed optimization results.

Usage:
    from livecap_cli.vad.presets import get_optimized_preset, get_available_presets
    from livecap_cli.vad import VADConfig

    # Get preset for specific VAD, language, and engine
    preset = get_optimized_preset("silero", "ja", "parakeet_ja")
    if preset:
        vad_config = VADConfig.from_dict(preset["vad_config"])

    # Get best preset across all engines
    preset = get_optimized_preset("silero", "ja")

    # Check available presets
    print(get_available_presets())  # [('silero', 'ja', 'parakeet_ja'), ...]
"""

from __future__ import annotations

import json
from importlib.resources import files
from typing import Any

__all__ = [
    "get_optimized_preset",
    "get_available_presets",
    "get_best_vad_for_language",
]

# ---------------------------------------------------------------------------
# Validation
# ---------------------------------------------------------------------------

_SUPPORTED_METRICS = ("cer", "wer")

_REQUIRED_KEYS: dict[str, type | tuple[type, ...]] = {
    "vad_type": str,
    "language": str,
    "vad_config": dict,
    "metadata": dict,
}

_REQUIRED_VAD_CONFIG_KEYS: dict[str, type | tuple[type, ...]] = {
    "min_speech_ms": (int, float),
    "min_silence_ms": (int, float),
    "speech_pad_ms": (int, float),
}

# Optional vad_config keys: not required (e.g. WebRTC doesn't use threshold),
# but if present they must have the correct type.
_OPTIONAL_VAD_CONFIG_KEYS: dict[str, type | tuple[type, ...]] = {
    "threshold": (int, float),
    "neg_threshold": (int, float),
}

_REQUIRED_METADATA_KEYS: dict[str, type | tuple[type, ...]] = {
    "score": (int, float),
    "metric": str,
    "trials": (int, float),
    "engine": str,
    "created_at": str,
}


def _validate_preset(data: dict[str, Any], source: str) -> None:
    """Validate a preset dictionary against the required schema.

    Args:
        data: Parsed JSON data.
        source: File path or identifier for error messages.

    Raises:
        ValueError: If required keys are missing or have wrong types.
    """
    # Top-level keys
    for key, expected_type in _REQUIRED_KEYS.items():
        if key not in data:
            raise ValueError(
                f"Preset '{source}': missing required key '{key}'. "
                f"Required top-level keys: {list(_REQUIRED_KEYS.keys())}"
            )
        if not isinstance(data[key], expected_type):
            raise ValueError(
                f"Preset '{source}': key '{key}' must be {expected_type.__name__}, "
                f"got {type(data[key]).__name__}"
            )

    # backend type check (optional key, but must be dict if present)
    if "backend" in data and not isinstance(data["backend"], dict):
        raise ValueError(
            f"Preset '{source}': key 'backend' must be dict, "
            f"got {type(data['backend']).__name__}"
        )

    # vad_config keys (required)
    vad_config = data["vad_config"]
    for key, expected_type in _REQUIRED_VAD_CONFIG_KEYS.items():
        if key not in vad_config:
            raise ValueError(
                f"Preset '{source}': missing required key 'vad_config.{key}'. "
                f"Required vad_config keys: {list(_REQUIRED_VAD_CONFIG_KEYS.keys())}"
            )
        if not isinstance(vad_config[key], expected_type):
            type_names = (
                expected_type.__name__
                if isinstance(expected_type, type)
                else "/".join(t.__name__ for t in expected_type)
            )
            raise ValueError(
                f"Preset '{source}': key 'vad_config.{key}' must be {type_names}, "
                f"got {type(vad_config[key]).__name__}"
            )

    # vad_config keys (optional — type-checked only when present)
    for key, expected_type in _OPTIONAL_VAD_CONFIG_KEYS.items():
        if key in vad_config and not isinstance(vad_config[key], expected_type):
            type_names = (
                expected_type.__name__
                if isinstance(expected_type, type)
                else "/".join(t.__name__ for t in expected_type)
            )
            raise ValueError(
                f"Preset '{source}': key 'vad_config.{key}' must be {type_names}, "
                f"got {type(vad_config[key]).__name__}"
            )

    # metadata keys
    metadata = data["metadata"]
    for key, expected_type in _REQUIRED_METADATA_KEYS.items():
        if key not in metadata:
            raise ValueError(
                f"Preset '{source}': missing required key 'metadata.{key}'. "
                f"Required metadata keys: {list(_REQUIRED_METADATA_KEYS.keys())}"
            )
        if not isinstance(metadata[key], expected_type):
            type_names = (
                expected_type.__name__
                if isinstance(expected_type, type)
                else "/".join(t.__name__ for t in expected_type)
            )
            raise ValueError(
                f"Preset '{source}': key 'metadata.{key}' must be {type_names}, "
                f"got {type(metadata[key]).__name__}"
            )

    # metric value validation
    metric = metadata["metric"]
    if metric not in _SUPPORTED_METRICS:
        raise ValueError(
            f"Preset '{source}': metadata.metric must be one of "
            f"{list(_SUPPORTED_METRICS)}, got '{metric}'"
        )


# ---------------------------------------------------------------------------
# Loading
# ---------------------------------------------------------------------------

def _load_presets() -> dict[str, dict[str, dict[str, dict[str, Any]]]]:
    """Load all preset JSON files from the package directory.

    Returns:
        Nested dict: ``{vad_type: {language: {engine: preset_data}}}``
        where ``preset_data`` contains ``vad_config``, optional ``backend``,
        and ``metadata``.

    Raises:
        ValueError: If any JSON file fails validation.
    """
    package = files(__package__)
    presets: dict[str, dict[str, dict[str, dict[str, Any]]]] = {}

    for resource in package.iterdir():
        if not hasattr(resource, "name") or not resource.name.endswith(".json"):
            continue

        source = resource.name
        raw = resource.read_text(encoding="utf-8")
        data = json.loads(raw)

        _validate_preset(data, source)

        # Ensure backend defaults to {}
        if "backend" not in data:
            data["backend"] = {}

        vad_type = data["vad_type"]
        language = data["language"]
        engine = data["metadata"]["engine"]

        # Build the preset entry
        entry: dict[str, Any] = {
            "vad_config": data["vad_config"],
            "metadata": data["metadata"],
        }
        if data["backend"]:
            entry["backend"] = data["backend"]

        presets.setdefault(vad_type, {}).setdefault(language, {})[engine] = entry

    return presets


# Module-level cache: loaded once on first import
_PRESETS: dict[str, dict[str, dict[str, dict[str, Any]]]] = _load_presets()


# ---------------------------------------------------------------------------
# Public API
# ---------------------------------------------------------------------------

def get_optimized_preset(
    vad_type: str,
    language: str,
    engine: str | None = None,
) -> dict[str, Any] | None:
    """Get optimized preset for VAD type, language, and optionally engine.

    Args:
        vad_type: VAD backend type ("silero", "tenvad", "webrtc")
        language: Language code ("ja", "en")
        engine: Engine ID (e.g. "parakeet_ja", "qwen3asr").
            If None, returns the preset with the best (lowest) score
            across all engines.

    Returns:
        Preset dictionary with "vad_config", optional "backend", and "metadata" keys.
        Returns None if no preset exists for the combination.

    Example:
        >>> preset = get_optimized_preset("silero", "ja", "parakeet_ja")
        >>> preset["vad_config"]["threshold"]
        0.294
        >>> preset["metadata"]["score"]
        0.082
    """
    engines = _PRESETS.get(vad_type, {}).get(language)
    if not engines:
        return None

    if engine is not None:
        return engines.get(engine)

    # engine=None → return best (lowest score) across all engines
    best: dict[str, Any] | None = None
    best_score = float("inf")
    for entry in engines.values():
        score = entry["metadata"]["score"]
        if score < best_score:
            best_score = score
            best = entry
    return best


def get_available_presets() -> list[tuple[str, str, str]]:
    """Get list of available (vad_type, language, engine) combinations.

    Returns:
        List of tuples (vad_type, language, engine) for all available presets.

    Example:
        >>> get_available_presets()
        [('silero', 'ja', 'parakeet_ja'), ('silero', 'ja', 'qwen3asr'), ...]
    """
    result = []
    for vad_type, languages in _PRESETS.items():
        for language, engines in languages.items():
            for engine in engines:
                result.append((vad_type, language, engine))
    return result


def get_best_vad_for_language(
    language: str,
    engine: str | None = None,
) -> tuple[str, dict[str, Any]] | None:
    """Get the best performing VAD preset for a language.

    Args:
        language: Language code ("ja", "en")
        engine: Engine ID to filter by. If None, searches across all engines.

    Returns:
        Tuple of (vad_type, preset) for the best performing VAD.
        Returns None if no presets exist for the language.

    Example:
        >>> vad_type, preset = get_best_vad_for_language("ja")
        >>> vad_type
        'tenvad'
        >>> preset["metadata"]["score"]
        0.072
    """
    best_vad = None
    best_score = float("inf")

    for vad_type, languages in _PRESETS.items():
        if language not in languages:
            continue
        engines = languages[language]

        if engine is not None:
            # Filter to specific engine
            if engine in engines:
                entry = engines[engine]
                score = entry["metadata"]["score"]
                if score < best_score:
                    best_score = score
                    best_vad = (vad_type, entry)
        else:
            # Search across all engines
            for entry in engines.values():
                score = entry["metadata"]["score"]
                if score < best_score:
                    best_score = score
                    best_vad = (vad_type, entry)

    return best_vad
